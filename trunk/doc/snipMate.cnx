*snipMate.txt*  一个 Vim 里使用 TextMate 风格的片段补全插件。



snipMate                                       *snippet* *snippets* *snipMate*
最后修改：2009/07/13
    翻译：2010/03/09
    译者：闲耘™(hotoo.cn[AT]gmail.com)

|snipMate-description|   描述
|snipMate-syntax|        语法
|snipMate-usage|         用法
|snipMate-settings|      设置
|snipMate-features|      特性
|snipMate-disadvantages| 缺陷
|snipMate-contact|       联系方式

支持 Vim 7.0 或更高版本。
这个插件需要设置 'compatible' ，否则无法工作。
{Vi 不支持这些特性。}

==============================================================================
描述                                                    *snipMate-description*

snipMate.vim 为 Vim 实现了一些 TextMate 的片段(补全)特性，片段就是使用一个
关键字后加 <tab> 键来插入一些常用的文本。

例如，在 C 文件中使用默认安装的 snipMate.vim，如果在插入模式下输入 `for<tab>`，
它将展开为典型的 C 循环： >

 for (i = 0; i < count; i++) {

 }


要转到下一个循环项，只需要简单的按 <tab> 键；如果是重复的代码，例如示例中的
变量 `i`，只需要在高亮处输入文本，所有指定匹配的项都将被更新。要返回到上一项，
使用 <shift-tab> 就可以了。

==============================================================================
语法                                                          *snippet-syntax*

有两种方式定义片段，一种是定义在 'snippets/<filetype>/<trigger>.snippet'文件
中，另一种则定义在 'snippets/<filetype>.snippets'文件中。
(译注：<filetype> 是文件类型，如 html，<trigger> 是关键字。)
注意，文件类型(filetype)支持点号(.) -- 例如，可以使用 >

	:set ft=html.eruby

为当前文件同时激活 HTML 和 eRuby 两种片段。

*.snippets 文件的片段语法如下： >

 snippet 关键字
 	将被展开的文本
	更多被展开的文本

注意：关键字之后的片段中，最前面的硬 TAB 字符是必须的，并且不会展开到实际展开后
的文本中。*.snippet 文件也一样，除非声明关键字时，以缩进开始。

另外注意：片段必须使用硬 TAB 空白来定义，如果需要的话可以展开为空格
（参考 |snipMate-indenting|）。

井号(#) 用来作为 *.snippets 文件的单行注释，当然，它们只能用在片段定义之外，
例如： >

 # 这是一个正确的注释
 snippet trigger
 	expanded text
 snippet another_trigger
 	# 这不是一个注释！
	expanded text
<
这从语法着色上可以明显看出来。

                                                               *snipMate-${#}*
制表符(Tab stops) ~

默认情况下，光标被放置在片段的最后。可使用 "${#}"来指定下一个光标出现在哪里。
井号(#)即制表符的数字。例如：将光标放置在 <div> 标签的 id 属性值上，并允许用户
使用 <tab> 键跳转到 <div> 的中间：
 >
 snippet div
 	<div id="${1}">
		${2}
	</div>
<
                        *snipMate-placeholders* *snipMate-${#:}* *snipMate-$#*
占位符 ~

Placeholder text can be supplied using "${#:text}", where # is the number of
the tab stop. This text then can be copied throughout the snippet using "$#",
given # is the same number as used before. So, to make a C for loop: >

 snippet for
 	for (${2:i}; $2 < ${1:count}; $1++) {
		${4}
	}

This will cause "count" to first be selected and change if the user starts
typing. When <tab> is pressed, the "i" in ${2}'s position will be selected;
all $2 variables will default to "i" and automatically be updated if the user
starts typing.
NOTE: "$#" syntax is used only for variables, not for tab stops as in TextMate.

Variables within variables are also possible. For instance: >

 snippet opt
 	<option value="${1:option}">${2:$1}</option>

Will, as usual, cause "option" to first be selected and update all the $1
variables if the user starts typing. Since one of these variables is inside of
${2}, this text will then be used as a placeholder for the next tab stop,
allowing the user to change it if he wishes.

To copy a value throughout a snippet without supplying default text, simply
use the "${#:}" construct without the text; e.g.: >

 snippet foo
 	${1:}bar$1
<                                                          *snipMate-commands*
Interpolated Vim Script ~

Snippets can also contain Vim script commands that are executed (via |eval()|)
when the snippet is inserted. Commands are given inside backticks (`...`); for
TextMates's functionality, use the |system()| function. E.g.: >

 snippet date
 	`system("date +%Y-%m-%d")`

will insert the current date, assuming you are on a Unix system. Note that you
can also (and should) use |strftime()| for this example.

Filename([{expr}] [, {defaultText}])             *snipMate-filename* *Filename()*

Since the current filename is used often in snippets, a default function
has been defined for it in snipMate.vim, appropriately called Filename().

With no arguments, the default filename without an extension is returned;
the first argument specifies what to place before or after the filename,
and the second argument supplies the default text to be used if the file
has not been named. "$1" in the first argument is replaced with the filename;
if you only want the filename to be returned, the first argument can be left
blank. Examples: >

 snippet filename
 	`Filename()`
 snippet filename_with_default
 	`Filename('', 'name')`
 snippet filename_foo
 	`filename('$1_foo')`

The first example returns the filename if it the file has been named, and an
empty string if it hasn't. The second returns the filename if it's been named,
and "name" if it hasn't. The third returns the filename followed by "_foo" if
it has been named, and an empty string if it hasn't.

                                                                   *multi_snip*
To specify that a snippet can have multiple matches in a *.snippets file, use
this syntax: >

 snippet trigger A description of snippet #1
 	expand this text
 snippet trigger A description of snippet #2
 	expand THIS text!

In this example, when "trigger<tab>" is typed, a numbered menu containing all
of the descriptions of the "trigger" will be shown; when the user presses the
corresponding number, that snippet will then be expanded.

To create a snippet with multiple matches using *.snippet files,
simply place all the snippets in a subdirectory with the trigger name:
'snippets/<filetype>/<trigger>/<name>.snippet'.

==============================================================================
USAGE                                                         *snipMate-usage*

                                                 *'snippets'* *g:snippets_dir*
Snippets are by default looked for any 'snippets' directory in your
'runtimepath'. Typically, it is located at '~/.vim/snippets/' on *nix or
'$HOME\vimfiles\snippets\' on Windows. To change that location or add another
one, change the g:snippets_dir variable in your |.vimrc| to your preferred
directory, or use the |ExtractSnips()|function. This will be used by the
|globpath()| function, and so accepts the same syntax as it (e.g.,
comma-separated paths).

ExtractSnipsFile({directory}, {filetype})     *ExtractSnipsFile()* *.snippets*

ExtractSnipsFile() extracts the specified *.snippets file for the given
filetype. A .snippets file contains multiple snippet declarations for the
filetype. It is further explained above, in |snippet-syntax|.

ExtractSnips({directory}, {filetype})             *ExtractSnips()* *.snippet*

ExtractSnips() extracts *.snippet files from the specified directory and
defines them as snippets for the given filetype. The directory tree should
look like this: 'snippets/<filetype>/<trigger>.snippet'. If the snippet has
multiple matches, it should look like this:
'snippets/<filetype>/<trigger>/<name>.snippet' (see |multi_snip|).

                                                            *ResetSnippets()*
The ResetSnippets() function removes all snippets from memory. This is useful
to put at the top of a snippet setup file for if you would like to |:source|
it multiple times.

                                             *list-snippets* *i_CTRL-R_<Tab>*
If you would like to see what snippets are available, simply type <c-r><tab>
in the current buffer to show a list via |popupmenu-completion|.

==============================================================================
SETTINGS                                  *snipMate-settings* *g:snips_author*

The g:snips_author string (similar to $TM_FULLNAME in TextMate) should be set
to your name; it can then be used in snippets to automatically add it. E.g.: >

 let g:snips_author = 'Hubert Farnsworth'
 snippet name
 	`g:snips_author`
<
                                     *snipMate-expandtab* *snipMate-indenting*
If you would like your snippets to be expanded using spaces instead of tabs,
just enable 'expandtab' and set 'softtabstop' to your preferred amount of
spaces. If 'softtabstop' is not set, 'shiftwidth' is used instead.

                                                              *snipMate-remap*
snipMate does not come with a setting to customize the trigger key, but you
can remap it easily in the two lines it's defined in the 'after' directory
under 'plugin/snipMate.vim'. For instance, to change the trigger key
to CTRL-J, just change this: >

 ino <tab> <c-r>=TriggerSnippet()<cr>
 snor <tab> <esc>i<right><c-r>=TriggerSnippet()<cr>

to this: >
 ino <c-j> <c-r>=TriggerSnippet()<cr>
 snor <c-j> <esc>i<right><c-r>=TriggerSnippet()<cr>

==============================================================================
FEATURES                                                   *snipMate-features*

snipMate.vim has the following features among others:
  - The syntax of snippets is very similar to TextMate's, allowing
    easy conversion.
  - The position of the snippet is kept transparently (i.e. it does not use
    markers/placeholders written to the buffer), which allows you to escape
    out of an incomplete snippet, something particularly useful in Vim.
  - Variables in snippets are updated as-you-type.
  - Snippets can have multiple matches.
  - Snippets can be out of order. For instance, in a do...while loop, the
    condition can be added before the code.
  - [New] File-based snippets are supported.
  - [New] Triggers after non-word delimiters are expanded, e.g. "foo"
    in "bar.foo".
  - [New] <shift-tab> can now be used to jump tab stops in reverse order.

==============================================================================
DISADVANTAGES                                         *snipMate-disadvantages*

snipMate.vim currently has the following disadvantages to TextMate's snippets:
    - There is no $0; the order of tab stops must be explicitly stated.
    - Placeholders within placeholders are not possible. E.g.: >

      '<div${1: id="${2:some_id}}">${3}</div>'
<
      In TextMate this would first highlight ' id="some_id"', and if
      you hit delete it would automatically skip ${2} and go to ${3}
      on the next <tab>, but if you didn't delete it it would highlight
      "some_id" first. You cannot do this in snipMate.vim.
    - Regex cannot be performed on variables, such as "${1/.*/\U&}"
    - Placeholders cannot span multiple lines.
    - Activating snippets in different scopes of the same file is
      not possible.

Perhaps some of these features will be added in a later release.

==============================================================================
CONTACT                                   *snipMate-contact* *snipMate-author*

To contact the author (Michael Sanders), please email:
 msanders42+snipmate <at> gmail <dot> com

I greatly appreciate any suggestions or improvements offered for the script.

==============================================================================

vim:tw=78:ts=8:ft=help:norl:
